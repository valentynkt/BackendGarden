---
created: 2024-09-02 22:16
aliases:
  - Async Flow
tags:
  - LearningIT
  - seedðŸŒ±
---
///
link: [[Asynchronous CSharp|Asynchronous]]

# Asynchronous Control Flow

## Overview

Asynchronous programming in C# using the `async` and `await` keywords allows developers to write non-blocking code, improving application responsiveness and scalability. While these keywords simplify asynchronous operations, understanding the underlying control flow is crucial for avoiding common pitfalls and ensuring that your code behaves as expected.

---

## Blocking vs. Non-Blocking Code

> [!abstract] Blocking Code
> 
> Blocking code prevents the current thread from executing any further until a specific operation completes. Examples of blocking code include:
> 
> ``` csharp
> System.Threading.Thread.Sleep(1000);
> var myTask = httpClient.GetStringAsync("https://...");
> var myString = myTask.GetAwaiter().GetResult();
> myTask.Wait();
> 
> ```
> In each of these cases, the thread is halted until the operation finishes, making the application unresponsive during this time.

> [!abstract] Non-Blocking code with 'await'
> Non-Blocking Code with `await`
> 
> The `await` keyword, in contrast, is non-blocking. It pauses the execution of the current method but does not block the thread. The thread is free to perform other tasks, such as handling user input or processing other requests.
> 
> ``` csharp
> await Task.Delay(1000); // Non-blocking pause
> ```

## Asynchronous Control Flow

### User Perspective: Keeping Applications Responsive

Using `await` ensures that your application remains responsive, even during long-running operations. For example, in a GUI application, using `await` prevents the UI from freezing, allowing the user to interact with other elements, such as clicking buttons or moving windows, while a background task completes.

---

### Method Perspective: Understanding Execution Order

When a method with `await` is called, the calling method does not wait for the entire asynchronous operation to complete. Instead, it continues executing the subsequent code immediately after encountering the first `await`. This can lead to situations where subsequent actions (like displaying a success message) occur before the asynchronous operation finishes.

> [!example]-
> ``` csharp
> async void OnButtonClick()
> {
>     Console.WriteLine("button clicked");
>     await DownloadAndBlur("https://...jpg");
>     Console.WriteLine("about to show dialog");
>     ShowDialog("Success!");
>     Console.WriteLine("dialog shown");
> }
> ```
> 
> In the above example, using `await` ensures that the "Success!" dialog is shown only after the `DownloadAndBlur` method has completed all its tasks.

## Resuming a Method After `await`

When a method awaits an asynchronous operation, the compiler generates a state machine to manage the control flow. This state machine ensures that the method can pause at the `await` keyword and resume execution once the awaited task completes.

**Key Points:**

- The state machine uses internal methods (like `MoveNext` and `SetResult`) to track the method's execution state.
- Understanding this helps in debugging asynchronous methods and ensures that the control flow behaves as expected.

## Summary

Asynchronous control flow in C# allows for non-blocking code execution, which is critical for maintaining application responsiveness. By understanding the difference between blocking and non-blocking code, and how `await` impacts method execution, developers can write more efficient and user-friendly applications.

## Related Topics

> [!info] **Related Topics**
> 
> - **[[Async and Await Keywords]]**: The foundation of asynchronous programming in C#.
> - **[[Task Parallel Library (TPL)]]**: The underlying framework that powers `async` and `await`.
> - **[[Multithreading]]**: How asynchronous programming compares with multithreading.
> - **[[Async and Await State Machine]]**: In-depth look at the state machine generated by the compiler.

# Reference:

https://www.pluralsight.com/guides/understand-control-flow-async-await/

