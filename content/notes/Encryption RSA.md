Date and Time: <u> 2023-10-27 20:42 </u>
Status: #LearningIT
Tags: [[Cryptography]], [[Cryptography Encryption]]

# Encryption RSA

**RSA** is an encryption [algorithm](https://brilliant.org/wiki/algorithm/ "algorithm"), used to securely transmit messages over the internet. It is based on the principle that it is easy to multiply large numbers, but [factoring](https://brilliant.org/wiki/factors/ "factoring") large numbers is very difficult. For example, it is easy to check that 31 and 37 multiply to 1147, but trying to find the factors of 1147 is a much longer process.
## Intro
For encryption, Bob encrypts a plaintext message with Alice’s public key, and she decrypts the ciphertext with her private key:
![[Pasted image 20231027204301.png]]

## RSA Algorithm
### Key Generation

You need to generate public and private keys before running the functions to generate your ciphertext and plaintext. They use certain variables and parameters, all of which are explained below:

``` ad-important
- Choose two large prime numbers (p and q)
- Calculate n = `p*q and z = (p-1)(q-1)`
- Choose a number e where 1 < e < z
- Calculate d = e-1mod(p-1)(q-1)
- You can bundle private key pair as (n,d)
- You can bundle public key pair as (n,e)
```

### Algorithm
In RSA, the public key is generated by multiplying two large [prime numbers](https://brilliant.org/wiki/prime-numbers/ "prime numbers") p and q together, and the private key is generated through a different process involving p and q. A user can then distribute his public key pq, and anyone wishing to send the user a message would encrypt their message using the public key. For all practical purposes, even computers cannot factor large numbers into the product of two primes, in the same way that factoring a number like 414863 by hand is virtually impossible. However, ​_multiplying_​ two numbers is much less difficult, so a potential factorization can be verified quickly


When the user receives the encrypted message, they decrypt it using the private key and can read the original text. A more detailed and technical explanation follows in the next section.

``` ad-important
1. First, the receiver chooses two large [prime numbers](https://brilliant.org/wiki/prime-numbers/ "prime numbers") p and q. Their product, n=pq, will be half of the public key.
2. The receiver calculates `ϕ(pq)=(p−1)(q−1)` and chooses a number e [relatively prime](https://brilliant.org/wiki/relatively-prime/ "relatively prime") to `ϕ(pq)`. In practice, e is often chosen to be `2^16+1=65537`, though it can be as small as 3 in some cases. e will be the other half of the public key.
3. The receiver calculates the modular inverse `d of e` modulo ϕ(n). In other words, `de≡1(modϕ(n))`. `d` is the **private key**.
4. The receiver distributes both parts of the public key: n and e. � is kept secret.
```

Now that the public and private keys have been generated, they can be reused as often as wanted. To transmit a message, follow these steps:

First, the sender converts his message into a number m. One common conversion process uses the ASCII alphabet:

|   |   |   |   |   |   |   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|---|---|---|---|---|---|
|A|B|C|D|E|F|G|H|I|J|K|L|M|
|65|66|67|68|69|70|71|72|73|74|75|76|77|
|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|
|78|79|80|81|82|83|84|85|86|87|88|89|90|

For example, the message "HELLO" would be encoded as 7269767679. It is important that `m<n` , as otherwise the message will be lost when taken modulo `n`, so if `n` is smaller than the message, it will be sent in pieces.

1. The sender then calculates `c≡m^e(mod n)`. c is the **ciphertext**, or the encrypted message. Besides the public key, this is the only information an attacker will be able to steal.
2. The sender then calculates `c≡m^e(mod n)`. c is the **ciphertext**, or the encrypted message. Besides the public key, this is the only information an attacker will be able to steal.
3. The receiver computes `cd≡m(mod n)` , thus retrieving the original number m.
4. The receiver translates m back into letters, retrieving the original message.

Note that step 3 makes use of Euler's theorem.
Usually we encrypt with E and decrypt with D
### Real Example

To create a RSA key pair, first randomly pick the two prime numbers to obtain the maximum _(max)_. Then pick a number to be the public key _pub_. As long as you know the two prime numbers, you can compute a corresponding private key _priv_ from this public key. This is how factoring relates to breaking RSA — factoring the maximum number into its component primes allows you to compute someone's private key from the public key and decrypt their private messages.

Let's make this more concrete with an example. Take the prime numbers 13 and 7, their product gives us our maximum value of 91. Let's take our public encryption key to be the number 5. Then using the fact that we know 7 and 13 are the factors of 91 and applying an algorithm called the [Extended Euclidean Algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm), we get that the private key is the number 29.

These parameters (_max_: 91, _pub_: 5; _priv_: 29) define a fully functional RSA system. You can take a number and multiply it by itself 5 times to encrypt it, then take that number and multiply it by itself 29 times and you get the original number back.

Let's use these values to encrypt the message "CLOUD".

In order to represent a message mathematically we have to turn the letters into numbers. A common representation of the Latin alphabet is UTF-8. Each character corresponds to a number.

![[Pasted image 20231028020245.png]]

Under this encoding, CLOUD is 67, 76, 79, 85, 68. Each of these digits are smaller than our maximum of 91, so we can encrypt them individually. Let's start with the first letter.

We have to multiply it by itself 5 times to get the encrypted value.

67×67 = 4489 = 30 *

>Since 4489 is larger than max, we have to wrap it around. We do that by **dividing by 91** and **taking the remainder**.

``` 
4489 = 91×49 + 30
30×67 = 2010 = 8
8×67 = 536 = 81
81×67 = 5427 = 58
```

This means the encrypted version of 67 is 58.
Repeating the process for each of the letters we get that the encrypted message CLOUD becomes:
`58, 20, 53, 50, 87`

To decrypt this scrambled message, we take each number and multiply it by itself 29 times:

```
58×58 = 3364 = 88 (remember, we wrap around when the number is greater than _max_)>
88×58 = 5104 = 8
...
9×58 = 522 = 67
```

Voila, we're back to 67. This works with the rest of the digits, resulting in the original message.

``` ad-important
The takeaway is that you can take a number, multiply it by itself a number of times to get a random-looking number, then multiply that number by itself a secret number of times to get back to the original number.
```

## RSA Problems
The gap between the difficulty of factoring large numbers and multiplying large numbers is shrinking as the number (i.e. the key's bit length) gets larger. As the resources available to decrypt numbers increase, the size of the keys need to grow even faster. This is not a sustainable situation for mobile and low-powered devices that have limited computational power. The gap between factoring and multiplying is not sustainable in the long term.

All this means is that RSA is not the ideal system for the future of cryptography. In an ideal Trapdoor Function, the easy way and the hard way get harder at the same rate with respect to the size of the numbers in question. We need a public key system based on a better Trapdoor.

[[Encryption EC|Elliptic curves]] is the best solution and more secure than RSA
## RSA [[Cryptography Digital Signature|Digital Signature]]

For a [[Cryptography Digital Signature|digital signature]], Alice signs a message with her private key, and Bob proves that she has signed it with her public key:

![[Pasted image 20231027204446.png]]

Along with being the most used public key encryption method, RSA is still the **most popular method for digital signing** (with most of the certificates we use to verify Web sites still mostly containing RSA public keys). While it’s not quantum robust, it is still the core of trust on the Internet. Without it, we could trust very little in our online world.
# Reference:
https://medium.com/asecuritysite-when-bob-met-alice/rsa-boxer-of-our-online-world-fe6a26a9bfa7


 